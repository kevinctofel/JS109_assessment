{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Root","n":1},"1":{"v":"# Welcome to Dendron\n\nThis is the root of your dendron vault. If you decide to publish your entire vault, this will be your landing page. You are free to customize any part of this page except the frontmatter on top.\n\n## Lookup\n\nThis section contains useful links to related resources.\n\n- [Getting Started Guide](https://link.dendron.so/6b25)\n- [Discord](https://link.dendron.so/6b23)\n- [Home Page](https://wiki.dendron.so/)\n- [Github](https://link.dendron.so/6b24)\n- [Developer Docs](https://docs.dendron.so/)","n":0.132}}},{"i":2,"$":{"0":{"v":"Terminal","n":1}}},{"i":3,"$":{"0":{"v":"Terminal Commands","n":0.707}}},{"i":4,"$":{"0":{"v":"Create New Folder","n":0.577},"1":{"v":"## Create a new folder\n\n```javascript\nmkdir new_directory\n```","n":0.408}}},{"i":5,"$":{"0":{"v":"Create new file","n":0.577},"1":{"v":"```javascript\ntouch new_filename.js\n```","n":0.707}}},{"i":6,"$":{"0":{"v":"Navigate up one folder","n":0.5},"1":{"v":"```javascript\ncd ..\n```","n":0.707}}},{"i":7,"$":{"0":{"v":"Navigate to folder","n":0.577},"1":{"v":"```javascript\ncd new_directory\n```","n":0.707}}},{"i":8,"$":{"0":{"v":"Delete a folder","n":0.577},"1":{"v":"\n```javascript\nrmdir foldername\n```\n\nNote: Folder must be empty of files. If not, use the rm command with the -R option to recursively remove all files in the folder and the folder.\n\n\n```javascript\nrm -R foldername\n```\n\n## References\n[rm man page](https://man7.org/linux/man-pages/man1/rm.1.html)","n":0.171}}},{"i":9,"$":{"0":{"v":"Delete a file","n":0.577},"1":{"v":"```javascript\nrm filename.js\n```","n":0.707}}},{"i":10,"$":{"0":{"v":"Nodejs","n":1},"1":{"v":"\n## What is Node.js?\n\n[Node.js](https://nodejs.org/en/) is the runtime environment that lets us run JavaScript outside of the browser.    \n\nNode.js is asynchronous and event driven, which is good for scalable network applications.\n\nSimple Node.js web server:\n```javascript\nconst http = require('http');\n\nconst hostname = '127.0.0.1';\nconst port = 3000;\n\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello World');\n});\n\nserver.listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});\n```\n\n\n## References\n[Node.js download page](https://nodejs.org/en/download/)\n\n","n":0.123}}},{"i":11,"$":{"0":{"v":"Version","n":1},"1":{"v":"\n```javascript\nnode -v\n```","n":0.707}}},{"i":12,"$":{"0":{"v":"Runtime","n":1},"1":{"v":"### Node.js runtime environment\n\n## What does [[Nodejs]] need to do at a minimum?\n1. Read and write disk files\n2. Read and write via a terminal\n3. Send and receive messages over a network\n4. Interact with a database\n\n","n":0.169}}},{"i":13,"$":{"0":{"v":"Run","n":1},"1":{"v":"\nRun a JavaScript app in node:\n\n```javascript\nnode nameOfFile.js\n```\n\nThis method executes the JavaScript file by an intepreter.\n\n```CTRL + C``` stops a running JavaScript file in Node.js.","n":0.204}}},{"i":14,"$":{"0":{"v":"Repl","n":1},"1":{"v":"\nNode.js REPL is a CLI enviornment to run JavaScript code one line at a time.\n\nExample:\n```javascript\n$ node\n> console.log(\"Hello, World!\")\nHello, World!\nundefined\n> 3 + 4\n7\n> Control-D (or Control-C twice) to exit\n$\n```","n":0.189}}},{"i":15,"$":{"0":{"v":"NPM","n":1},"1":{"v":"## Node.js Package Manager\n\n[npm homepage](https://www.npmjs.com/)","n":0.447}}},{"i":16,"$":{"0":{"v":"JavaScript","n":1},"1":{"v":"\nCreated in 1995 by Brendan Eich at Netscape.\n\n[[Nodejs]] was created by Ryan Dahl after Google developed the Chrome V8 JavaScript engine in 2008.\n\n## References:\n\n* [ECMAScript](https://262.ecma-international.org/12.0/)\n* [ES 6 spec](https://262.ecma-international.org/6.0/)\n* [Dev Docs](https://devdocs.io/javascript/)\n* [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference)","n":0.18}}},{"i":17,"$":{"0":{"v":"Variables","n":1},"1":{"v":"## Variables in JavaScript\n\nNamed area in memory to store data.\nShould be descriptive so someone reading code will know exactly what the function does.\n\nPart of the broader term called identifiers:\n- Variable names declared by let and var\n- Constant names declared by const\n- Property names of objects\n- Function names\n- Function parameters\n- Class names\n\n## Variables as Pointers\n\n### Working with primitive values\n```js\nlet count = 1;\ncount = 2;\n```\nAbove we declare a variable called ```count``` and initialize its value to ```1```. Next we assign the value ```2``` to the variable. \n\nWith most primitive values, the variable points to a particular space in memory, or memory location, where the value of the variable is stored.\n\n### Working with Objects and non-mutating operations\n```js\nlet obj = { a: 1 };\nobj = { b: 2 };\n```\nAbove we declare an object with the variable name ```obj``` and assign it the key-value pair of ```a: 1```. Next we assign another key-value pair to the same ```obj``` variable. The object contains a new key-value pairs but the memory location of the object is unchanged. \n![Object stored in memory](assets/images/Screenshot%20from%202023-03-06%2011-22-48.png)\n\nObject variables point to memory locations that then point to the stored the stored values. In other words, the variables point to memory references, not the to the actual values being stored.\n\n\n\n\n","n":0.07}}},{"i":18,"$":{"0":{"v":"Scope","n":1},"1":{"v":"## Variable scope in JavaScript\n\nScope determines where variables and their data are available to a program. \n\nBlock scope: ```let``` and ```const``` variables are accessible in the block they are declared. Blocks are defined by curly braces in JavaScript. These two variable types have the same scope.\n\nCode from one block cannot directly access variables declared in another block as those are out of scope.\n\nTechnically, not all code between curly braces is in a block. Object literals, for example do not define a block. Examples:\n```js\n{\n  // this is a block\n  let foo = 42;\n  console.log(foo);\n}\n\nfunction foo() {\n  // not technically a block. However, we can treat it as a block.\n  let foo = 42;               // foo has block scope\n  console.log(foo);\n}\n\nlet foo = {\n  // this is not a block\n  bar: 42,\n};\n```\n\nDue to block scope, this code returns an error as the variable ```a``` doesn't exist outside of the code block:\n```js\nif (1 === 1) {\n  let a = 'foo';\n}\n\nconsole.log(a); // ReferenceError: a is not defined\n```\n\n## Global Scope\n\nVariables in JavaScript with no functions or blocks have global scope. Additionally, any variables existing outside of functions or blocks have global scope.\n\n## Local Scope\n\nTwo forms of local scope: Function scope and block scope.\n\n### Function Scope\n\nVariable scope is determined by where it is declared, so if you declare a variable in a function it is available to the entire function. Note that nested functions have nested scope.\n\n1. Outer scope variables can be accessed by the inner scope, i.e.: a global variable can be accessed by a function.\n\n2. Inner scope variables can not be accessed by the outer scope. i.e.: code outside of a function can't directly access variables within that function. Typically JavaScript would return a ```ReferenceError``` as the variable is not defined globally.\n\n3. Peer scopes do not conflict, even with the same variable name. \n\n4. Nested functions have their own variable scope.\n\n5. Inner scope variables can shadow outer scope variables, i.e.: In cases when inner and outer scope variables have the same name, the inner variable prevents the outer variable from being accessed. Example:\n```js\nlet number = 10; // this 'number' is ignored below\n\n[1, 2, 3].forEach(number => {\n  console.log(number);\n});\n```\n\n### Block Scope\n\nBlocks are defined by statements and expressions within curly braces. The rules for block scope are the same as function scope, but limited to within the code block.\n","n":0.051}}},{"i":19,"$":{"0":{"v":"Reassignment and mutation","n":0.577},"1":{"v":"## Reassignment and mutation in JavaScript\n\n### Reassignment\nChanges the value assigned to a variable.\nHow? Variables point to the memory space where a value is stored, so we create a new memory space with a new value to reassign the variable. A reassigned variable points to this new memory space.\n\n### Mutation\nChange the value of the thing bound to the variable?\nHow? Mutation point to the values stored in memory, so we change the value where the variable points to. The variable still points to the same memory space.\n\nExamples:\n```js\nlet num = 3;              // A variable assigned to a primitive value\nlet arr = [1, 2, 3];      // A variable assigned to an array\nlet obj = { a: 1, b: 2 }; // A variable assigned to an object\n\nnum = 42;    // Reassignment\narr[1] = 42; // Reassignment of array element, but NOT the variable\n             // The array referenced by arr is mutated!\nobj.a = 42;  // Reassignment of object property, but NOT the variable\n             // The object referenced by obj is mutated.\n\n// You can still reassign the variables\narr = 42;                 // Reassignment; array is lost\nobj = { b: 1, c: 2 }      // Reassignment: now refers to a different object\n```\n\n## Mutating the caller\nExample of a non-mutating method, where the stored value of ```name``` remains unchanged:\n```js\nlet name = \"Pete Hanson\";\nconsole.log(name.toUpperCase()); // => 'PETE HANSON'\nconsole.log(name);               // => 'Pete Hanson'\n```\n```toUpperCase()``` returns a new value but leaves the original value as is.\n\nIn contrast, the ```pop``` method mutates an array (the caller) and is therefore destructive:\n```js\nlet oddNumbers = [1, 3, 5, 7, 9];\noddNumbers.pop();\nconsole.log(oddNumbers); // => [1, 3, 5, 7]\n```\nNote that primitive values are immutable so their values never change; where they point to in memory can change, however. \n\nFunctions can (but don't always) mutate arguments as well, although this applies only to global variables. Example:\n```js\nfunction changeFirstElement(array) {\n  array[0] = 9;\n}\n\nlet oneToFive = [1, 2, 3, 4, 5];\nchangeFirstElement(oneToFive);\nconsole.log(oneToFive); // => [9, 2, 3, 4, 5]\n```\n## Key concept of mutation\nPrimitive values are immutable. That means their values never change; operations on immutable values always return new values. Operations on mutable values (arrays and objects) may or may not return a new value and may or may not mutate data.\n\n","n":0.053}}},{"i":20,"$":{"0":{"v":"Pass by reference vs pass by value","n":0.378},"1":{"v":"## Pass by Value\n\nPassing a variable by value to a function means the function can't set the original variable to a different value. The original variable will still contain the original value.\n\nExample:\n```js\nfunction changeName(name) {\n  name = \"bob\"; // does this reassignment change the variable outside the function? NO\n}\n\nfunction anotherFunction() {\n  let name = \"jim\";\n  changeName(name);\n  console.log(name); // => logs 'jim'\n}\n\nanotherFunction();\n```\n\n## Pass by Reference\n\nExample of pass by reference:\n```js\nfunction capitalize(names) {\n  for (let index = 0; index < names.length; index++) {\n    names[index] = names[index][0].toUpperCase() + names[index].slice(1);\n  }\n}\n\nlet names = [\"chris\", \"kevin\", \"naveed\"];\ncapitalize(names);\nconsole.log(names); // => ['Chris', 'Kevin', 'Naveed']\n```\n\nSimilar example where the function doesn't change the values\n```js\nfunction capitalize(names) {\n  return names.map(name => name[0].toUpperCase() + name.slice(1));\n}\n\nlet names = [\"chris\", \"kevin\", \"naveed\"];\ncapitalize(names); // returns ['Chris', 'Kevin', 'Naveed']\nconsole.log(names); // => ['chris', 'kevin', 'naveed'] // The original object still has the original values because the capitalize() function doesn't mutate it. Instead, it returns a new array object.\n```\n\n## How JavaScript manages pass by value vs pass by reference\n\nPassing primitive values to functions is pass by value so functions don't mutate the primitive values.\n\nJavaScript always treats objects passed to functions as pass by reference, and therefore, can mutate those objects.\n\n**When an operation within the function mutates its argument, it affects the original object.**\n\nFunctions that mutate their callers are called destructive functions or methods. Example:\n```js\nfunction addNames(arr, name) {\n  arr.push(name);\n}\n\nlet names = [\"bob\", \"kim\"];\naddNames(names, \"jim\");\nconsole.log(names); // => [ 'bob', 'kim', 'jim' ]\n```\n\nReassignment is not a destructive operation. Example:\n```js\nfunction addName(arr, name) {\n  arr = arr.concat([name]); // not destructive\n}\n\nlet names = [\"bob\", \"kim\"];\naddName(names, \"jim\");\nconsole.log(names); // => [ 'bob', 'kim', ]\n```\n\nSimilar example with a destructive function:\n```js\nfunction addNames(arr, name) { \n  arr = arr.push(name); // destructive through mutation\n}\n\nlet names = [\"bob\", \"kim\"];\naddNames(names, \"jim\");\nconsole.log(names); // => [ 'bob', 'kim', 'jim' ]\n```\n\n## Return values\n\nValues returned by functions can be pass by value or pass by reference.\n\nExample of pass by value because the caller passes a primitive:\n```js\nfunction foo(number) {\n  return number;\n}\n\nlet number = 1;\nlet newNumber = foo(number);\nconsole.log(number);    // 1\nconsole.log(newNumber); // 1\n\nnumber = 3;\nconsole.log(number);    // 3\nconsole.log(newNumber); // 1\n```\n\nExample of pass by reference because the caller passes an object:\n```js\nfunction bar(array) {\n  return array;\n}\n\nlet array = [1, 2, 3];\nlet newArray = bar(array);\nconsole.log(array === newArray); // true (they are same object)\n\narray.push(4);\nconsole.log(array);    // [ 1, 2, 3, 4 ]\nconsole.log(newArray); // [ 1, 2, 3, 4 ]\n```\n\n## Assignment\n\nPass by value and pass by reference don't apply to assignment of variables.\n","n":0.051}}},{"i":21,"$":{"0":{"v":"Declaring and assigning variables","n":0.5},"1":{"v":"Variable declarations reserve memory space with a specific name, typically using 'let' (also 'var' but that's older and is slightly different because it supports hosting, i.e.: variables called in code before they're declared.)\n\nInitializing a variable can be done at the same time it is declared.\n\nDeclarations always return 'undefined'\n\nWhen declaring a variable, the '=' is not an operator but is a syntactic token.\nWhen assigning a value to a variable, the '=' is called the assignment operator. \n\n","n":0.115}}},{"i":22,"$":{"0":{"v":"Constants","n":1},"1":{"v":"## Constants in JavaScript\n\n```const``` keyword is similar to ```let``` but is used to store data or values that don't change.\n\nConstants are immutable so you can't assign new values to a declared constant.\n\nNamed constants are typically designated in all uppercase letters. You must assign a value when declaring a constant; which you don't have to do for a let statement.\n\n","n":0.13}}},{"i":23,"$":{"0":{"v":"Style","n":1},"1":{"v":" \n## General style\n- Two spaces for tabs with indentation set to spaces.\n\n- Comments:\n``` javascript\n// represents a single line comment\n/* is the start of a multiline comment\n** it's common for these in lines within a comment block\n*/ ends a multiline comment \n```\n\n- camelCase for general function, method or variable names.\n- snake_case or kebab-case for file names.\n- SCREAMING_SNAKE_CASE for constants or magic numbers.\n- CamelCase (aka: PascalCase) for constructor functions.\n\n## Code blocks using curly braces\n- First curly brace on the same line as the function name or conditional expression.\n- Closing curly brace after the code block\n\n## Operands\n- Use spaces between operands and operators:\n```javascript\nlet sum = x + 5; \n```\n\n## Semicolons\n- Used to terminate each logical line of code\n- Exceptions: If line ends with a curly brack or a colon\n- REPL style omits semicolons\n\n","n":0.088}}},{"i":24,"$":{"0":{"v":"Statements","n":1},"1":{"v":"## Statements in JavaScript\n\nUnlike expressions, you can't capture a value from a statements; they can't be used later in code like the value in an expression.\n\nExample:\n```js\n> let foo = 3;\n```\nThis is a declaration statement for the variable foo. The value of three, however, is an expression.\n\nAccording to MDN: 'a statement is a line of code commanding a task. Every program consists of a sequence of statements.'\n\n\n\n","n":0.123}}},{"i":25,"$":{"0":{"v":"Side effects","n":0.707},"1":{"v":"\n## Functions have side effects in these instances\n\n1. When a function reassigns a non-local (or outside of function scope) variable.\n2. When a function mutates an object value referenced by a non-local variable.\n3. When reading or writing to a file, network connection, browser or the console.\n4. When a function raises an exception without handling the exception.\n5. When a function calls another function that has side effects.\n\n**Functions should return a useful value OR have a side effect, but not BOTH.**\n\n","n":0.113}}},{"i":26,"$":{"0":{"v":"Runtime","n":1},"1":{"v":" ### JavaScript runtime environment\n\n ## Two main purposes\n\n 1. Programmatically change web content based on user actions or data.\n 2. Communicate with a server over a network to exchange data.","n":0.183}}},{"i":27,"$":{"0":{"v":"Run_in_browser","n":1},"1":{"v":"\n## Running JavaScript in the browser\n\nIn the HMTL code for the page; include a script tag, like this, pointing to the path of the JavaScript file: \n\n```<script src = \"my_javascript_code.js\"></script>```\n\n*Note: Inline JavaScript is allowed within script tags.*\n\nSave the HTML page and open it in the browser.\n\n","n":0.147}}},{"i":28,"$":{"0":{"v":"Regex","n":1},"1":{"v":"## RegEx\n\nRegular expressions are character sequences to test for matching patterns in strings. The RegEx sequence is placed between two forward slashes. You can store a RegEx in a variable or use a RegEx object. Example using the ```test()``` method on a RegEx object.\n```js\n> /o/.test('bobcat')\n= true\n\n> /l/.test('bobcat')\n= false\n```\nThe RegEx ```match()``` method returns an array with all matches, or ```null``` if there is no match.\n\nThe ```/g``` flag signifies a global match so the returned array includes all matching substrings.\n\n","n":0.113}}},{"i":29,"$":{"0":{"v":"Operations","n":1},"1":{"v":"## Operations in JavaScript\n\n### Operations on primitive data types\n\n* Addition uses the + operator\n* Subtraction uses the - operator\n* Multiplication uses the * operator\n* Division uses the / operator (for both integers and decimals)\n* Division remainder (not modulo) uses the % operator\n\nKey math difference between remainder and modulo:\n* Remainder returns a positive integer when first operand is positive and a ngative integer when first operand is negative.\n* Modulo retuns a positive integer when second operand is positive and a negative integer when second operand is negative.\n\nThis generally only affects JavaScript when either operand is a negative number.","n":0.102}}},{"i":30,"$":{"0":{"v":"Equality_compariso","n":1},"1":{"v":"## Equality comparison\n\nTriple equals, or ===, compares two operands for quality by value and type. This returns true or false.","n":0.224}}},{"i":31,"$":{"0":{"v":"Methods","n":1},"1":{"v":"\n### Method Chaining\nExample: \n```js\nlet str = 'Pete Hanson';\nlet names = str.toUpperCase().split(' ').reverse().join(', ');\nconsole.log(names); // => HANSON, PETE\n```\nNote the multiple methods chained together where methods are called on the return value of other methods.","n":0.174}}},{"i":32,"$":{"0":{"v":"Instance_vs_static","n":1},"1":{"v":"## Instance vs Static Methods\n\nInstance methods have ```.prototype.``` in their name.\n\nInstance methods are applied to a value type from the constuctor. Example:\n\n```String.prototype.concat('abc')```\n\nHowever, there is also a static concat method that can be applied to any string value. Example:\n\n```'The first letters of the alphabet are: '.concat('abc')```\n\nInstance methods are called on an instance of an object.\nStatic methods are called on the constructor of an object.","n":0.126}}},{"i":33,"$":{"0":{"v":"Math object","n":0.707},"1":{"v":"## Math object\n\nJavaScript's built-in ```Math``` object provides many methods for arithmetic calculations.\nExample:\n```js\n> Math.sqrt(36)\n= 6\n\n> Math.sqrt(2)\n= 1.4142135623730951\n```\n","n":0.25}}},{"i":34,"$":{"0":{"v":"Loops and Iterating","n":0.577},"1":{"v":"## Loops and Iterating\n\n### ```while``` Loops\nUseful when you don't know how many iterations to loop.\nWhile loops execute a code block until some condition is met. \nExample:\n```js\nlet counter = 1;\nwhile (counter <= 1000) {\n  console.log(counter);\n  counter = counter + 1;\n}\n```\n\n### Looping Over Arrays With while\nExample of iterating through an array of names with a ```while``` loop. While condition checks to see if we've iterated through all of the elements in the array, based on the length of the array. Note the index is incremented through each iteration of the loop.\n\n```js\nlet names = ['Chris', 'Kevin', 'Naveed', 'Pete', 'Victor'];\nlet upperNames = [];\nlet index = 0;\n\nwhile (index < names.length) {\n  let upperCaseName = names[index].toUpperCase();\n  upperNames.push(upperCaseName);\n  index += 1;\n}\n\nconsole.log(upperNames); // => ['CHRIS', 'KEVIN', 'NAVEED', 'PETE', 'VICTOR']\n```\n\n### Using a ```do/while``` loop\nSimilar to a ```while``` loop but guarantees that it will always run through the loop at least one time. Why? Because the ```while``` condition happens after each loop is executed, not before it.\n\n```js\nlet answer;\ndo {\n  answer = prompt(\"Do you want to do that again?\");\n} while (answer === 'y');\n```\n\n### ```for``` loops\nAnother way to implement a loop by specifying an initialization variable, a condition to evaluate, and an increment or decrement of the loop variable.\n\nExample of the above ```while``` loop rewritten as a ```for``` loop:\n```js\nlet names = ['Chris', 'Kevin', 'Naveed', 'Pete', 'Victor'];\nlet upperNames = [];\n\nfor (let index = 0; index < names.length; index += 1) {\n  let upperCaseName = names[index].toUpperCase();\n  upperNames.push(upperCaseName);\n}\n\nconsole.log(upperNames); // => ['CHRIS', 'KEVIN', 'NAVEED', 'PETE', 'VICTOR']\n```\n\n### Controlling loops with ```continue``` and ```break```\n\n```continue``` drops out of the current loop iteration and moves to the next one.\n```break``` terminates the loop early; no additional iterations of that loop will run.\n\n### Array Iteration\n\n```forEach``` is built in to JavaScript as a array method for array iteration without a formal loop.\n\n```js\nlet names = ['Chris', 'Kevin', 'Naveed', 'Pete', 'Victor'];\n\nnames.forEach(function(name) {\n  console.log(name);\n});\n```\n\nThis example passes a function expression to the ```forEach``` method as an anonymous function, i.e.: it has no name. This can also be consolidated into an arrow function:\n\n```js\nlet names = ['Chris', 'Kevin', 'Naveed', 'Pete', 'Victor'];\n\nnames.forEach(name => console.log(name));\n```\nNote that ```forEach``` doesn't return results of the function that it calls. It returns ```undefined```.\n\n### Recursion\n\nA recursive function is one that calls itself. Each call is added to the [call stack](./javascript.call_stack.md) as it waits for return values from the other function calls. Once the first function call returns a value the other functions on the stack can begin to return their values.\n\nExample using a function to calculate a Fibonacci number:\n```js\nfunction fibonacci(number) {\n  if (number < 2) return number; // 0 if number is 0, 1 if number is 1\n  return fibonacci(number - 1) + fibonacci(number - 2);\n}\n\nconsole.log(fibonacci(6));  // => 8\nconsole.log(fibonacci(20)); // => 6765\n```\n\nIn this example, none of the calling functions know the return values until the conditional is met: ```if (number < 2)```. At that point, functions on the stack begin passing their return values to the calling functions and so on through the stack.\n\nA recursive function must have a baseline condition, i.e.: the conditional in the above code.\n\n### for/in and for/of loops\n\n```for/in``` iterates over all enumerable properties of an object. Example:\n```js\nlet obj = { foo: 1, bar: 2, qux: 'c' };\nfor (let key in obj) {\n  console.log(key);\n}\n// Output:  foo\n//          bar\n//          qux\n```\nNote: Don't use ```for/in``` to iterate over arrays because the indices are stored as strings. Instead, use the ```for/of``` statement:\n```js\nlet arr = [ 10, 20, 30 ]\nfor (let value of arr) {\n  console.log(value);\n}\n// Output:  10\n//          20\n//          30\n```\n```for/of``` is also recommended when iterating through strings.\n\n\n","n":0.042}}},{"i":35,"$":{"0":{"v":"Input / Output","n":0.577},"1":{"v":"## Input and output in JavaScript\n\n### Command line output\n```console.log()``` provides command line output shown in the Terminal and in the console of a browser's dev tools.\n\n### Command line input\nAccepting user input requires a Node.js API called ```readline```. For our purposes, we use a library called ```readlineSync``` [available through NPM](https://www.npmjs.com/package/readline-sync).\n\nHow to install readline-sync: \n```js\n$ npm install readline-sync --save\nnpm notice created a lockfile as package-lock.\n```\n\nHow to use readlineSync:\n- Use the ```require``` function to import the readline-sync library.\n- Assign that function to a variable for later use.\n- Use that variable with the readline-sync methods: ```question()```, ```prompt()```, etc..\n```js\nlet rlSync = require('readline-sync');\nlet name = rlSync.question(\"What's your name?\\n\");\nconsole.log(`Good Morning, ${name}!`);\n```\nNote that ```question()``` returns string data, so when working with numbers, these must be coerced to the ```Number``` data type.\n\n### Browser input (basic)\nInclude a JS script in the HTML. In the script, use the ```prompt``` function for a user input popup box. Input can be stored as a variable and used elsewhere in the script.\n\n```js\nlet name = prompt(\"What's your name?\");\nconsole.log(`Good Morning, ${name}`);\n```\nThis data can be sent to the console via ```console.log()``` or through the ```alert``` function in the browser.\n","n":0.074}}},{"i":36,"$":{"0":{"v":"Functions","n":1},"1":{"v":"## Functions in JavaScript\n\n### Functions\nFunctions (or function objects) are defined by the ```function``` keyword. This can be skipped by using the name of a function when creating an arrow function, however.\n\n```js\nfunction say() {\n  console.log(\"Hi!\");\n}\n // OR\n const say = () => {\n  console.log(\"Hi!\");\n }\n ```\n\nTo reduce ambiguity we say we are \"invoking a function\" rather than \"calling a function\".\n\n### Arguments and Parameters\nWhen we invoke a function we are passing arguments from outside the function's scope so the function can use the data. The arguments are objects or primitive values.\n\nWhen defining a function, we declare any parameters the function accepts. Parameters are local variables initialized when the function is invoked. Therefore, when the function is complete, the parameters are destroyed.\n\nYou can pass more arguments than a function has parameters; they will be ignored. However, passing fewer arguments than a function requires causes an error as those missing parameters are assigned ```undefined```.\n\n```js\nfunction add(left, right) { // left & right are parameters here\n  let sum = left + right;   // left & right are arguments here\n  return sum;\n}\n\nconsole.log(add(3, 6, 5)); // 5 is ignored; prints 9\nconsole.log(add(3));       // second argument missing; prints NaN\n                           // 3 + undefined is NaN\n```\n\n### Return values\nThe ```return``` statement returns a result to the code that called a function.\nWithout a return statement, a JavaScript function will return ```undefined``` as the implicit return value.\nFunctions that always return a boolean value (true or false only) are predicates.\n\n### Default parameters\nYou can set default parameters for functions invoked without any arguments provided by setting the parameter to a default value:\n```js\nfunction say(text = \"hello\") {\n  console.log(text + \"!\");\n}\n\nsay(\"Howdy\"); // => Howdy!\nsay();        // => hello!\n```\n\n### Nested functions\nFunctions can be nested within other functions. Once the inner function completes, it and all of its local data, is destroyed.\n\n### Function scope\nGlobal variables are available to all code in a program, so any function has access to them. Functions can modify global variables.\n\nLocal variables defined inside of a function are only accessible within that function.\n\n### Functions vs. methods\nFunctions pass arguments within their parenthesis. So too do methods, but methods are pre-defined functions on objects so you have to call a method on an object using the period.\n\n## Function composition\nJavaScript lets a function call as an argument to another function via function composition. This is because function calls always return a value.\n\nExamples of passing a function call as an argument to the ```console.log()``` function:\n```js\nconsole.log(add(20, 45)); // => 65\nconsole.log(subtract(80, 10)); // => 70\n```\n\n## Defining a function (three ways)\n1. Create a function declaration and call the function.\n2. Create a function expression by setting a variable name equal to a function declaration.\n3. Use an arrow function, which is similar to option 2 but more concise. Arrow functions have implicit returns so you don't  need a ```return``` statement for a single expression. Example:\n```js\nlet add = (a, b) => a + b; // this returns the value of a + b\n```\nNote that function expressions are saved to a variable so they can't be invoked before definition.\n\n## First-class functions\nAll JavaScript functions are considered to be objects so they can be assigned to variables, passed as arguments and returned from function calls.\n","n":0.044}}},{"i":37,"$":{"0":{"v":"Flow control","n":0.707},"1":{"v":"## Flow Control in JavaScript\nHow a program branches off to do different things based on inputs, outputs, etc...\n\n### Conditionals\nChecking \"if\" something is or happens changes the path or flow of code.\n\nSimplest method is with ```if``` statements, which can also be followed by ```else``` conditions.\n\n```js\nif (x === 3) {                  // If statement\n  console.log(\"x is 3\");        // Clause to run\n}\n```\nNote in above example, the curly braces for the code block aren't needed. A single statement or expression doesn't require them but it's good practice.\n\n### Comparisons\nComparisons return the boolean values of ```true``` or ```false``` depending on the condition and the operands.\n\n| Operator | Description\n|---|---|\n|```===```| Strict equality of value and type ; returns ```true``` if they are the same |\n|```!==```| Strict inequality of value and type; returns ```false``` if they are the same|\n| ```==``` | Non-strict or loose equality. Attempts to coerce types of one or both operands. Returns ```true``` if values but not type are the same.|\n|```!=```| Non-strict or loose inequality. Attempt to coerce types of one or both operands. Returns ```false``` if values are the same, regardless of type.|\n| ```<``` | Less than returns ```true``` when left operand value is less than the right operand value|\n|```>``` | Greater than returns ```true``` when right operand value is greater than left operand value|\n|```<=``` | Less than or equal to returns ```true``` when left operand value is less than or equal to the right operand value|\n|```>=```| Greater than or equal to returns ```true``` when the left operand value is greater than or equal to the right operand value|\n| ```!```| Logical not operator, negates an operand|\n|```&&```| Logical and operator, returns ```true``` only if both operands are true|\n|&#124&#124| Logical or operator, returns ```true``` if either operand is true|\n\n\n### Short circuits\nLogical operators use short circuit evaluation so they can re-flow code sooner (or not at all) based on just the first operand.\n\nIn an ```&&``` evaluation, if the first operand returns ```false```, the second doesn't have to be evaluated.\n\nIn an ```||``` evaluation, if the first operand returns ```true```, the second doesn't have to be evaluated.\n\n### Truthiness\n```If``` statements always evaluated to ```true``` or ```false```. But expressions can be evaluated for truthiness by JavaScript coercion, where the expression value is changed to represent true or false.\n\nExamples: \n```js\na = 5\nif (a) {\n  console.log(\"how can this be true?\");\n} else {\n  console.log(\"it is not true\");\n}\n\nb = 0\nif (b) {\n  console.log(\"how can this be true?\");\n} else {\n  console.log(\"it is not true\");\n}\n```\nThe first statement is truthy because the value of ```a``` is coerced to ```true```.\nThe second statement is not truthy, or falsy, because the value of ```b``` is coerced to ```false```.\n\nWhy? JavaScript coerces the following values to ```false```:\n- false\n- The numbers 0, -0, and 0n\n- ```''```; an empty string\n- undefined\n- null\n- NaN\n\nAll other values are coerced to ```true``` in JavaScript.\n\nWith ```&&``` and ```||```, truthy and falsy can still short circuit, returning the value of the last evaluated operand.\nRather than test expressions with these with multiple code lines, use a ternary expression for clarity.\nExample:\n```js\n// Instead of this:\nlet foo = null;\nlet bar = 'qux';\nlet isOk = foo || bar;\n\n// Use a ternary expression like this:\nlet isOk = (foo || bar) ? true : false;\n```\n\n### Operator precedence\nFrom highest to lowest: \n- <=, <, >, >= - Comparison\n- ===, !==, ==, != - Equality\n- && - Logical AND\n- || - Logical OR\nNote: expressions in parenthesis take precedence over those that are not.\n\n### The ternary operator\nUses a combination of ```?```, ```:``` after the expression, with the truthy and falsy return values inserted.\nExample:\n```js\n> 1 == 1 ? 'this is true' : 'this is not true'\n= 'this is true'\n\n> 1 == 0 ? \"this is true\" : \"this is not true\"\n= 'this is not true'\n```\nWhy use a ternary expression over an ```if/else``` statement? Because it's a single expression and can be treated as value that can be stored, passed in as an argument, etc...\n\nTernary expressions should be used to select between two values, not two actions. It's good practice to assign the value of a ternary expression to a variable or passed as an argument.\nExample:\n```js\nlet foo = hitchhiker ? 42 : 3.1415;    // Assign result of ?: to a variable\nconsole.log(hitchhiker ? 42 : 3.1415); // Pass result as argument\nreturn hitchhiker ? 42: 3.1415;        // Return result\n```\n\n### Switch statements\nSimilar to an ```if``` statement but compares a single value against multiple values for strict equality. It evaluates the expression to the value in each ```case``` clause. The ```break``` statements effectively short circuit the ```switch``` statement by dropping out when the evaluation is truthy.\nExample:\n```js\nlet a = 5;\n\nswitch (a) {\n  case 5:\n    console.log('a is 5');\n    break;\n  case 6:\n    console.log('a is 6');\n    break;\n  default:\n    console.log('a is neither 5, nor 6');\n    break;\n} // => a is 5\n```\n\n```Switch``` statements can fall through multiple values that satisfy strict equality, like an ```||``` operator. \nExample:\n```js\nlet a = 5;\n\nswitch (a) {\n  case 5:\n  case 6:\n  case 7:\n    // executed if a is 5, 6, or 7\n    console.log(\"a is either 5, 6, or 7\");\n    break;\n  case 8:\n  case 9:\n    // executed if a is 8 or 9\n    console.log('a is 8 or 9');\n    break;\n  default:\n    // executed if a is anything else\n    console.log('a is not 5, 6, 7, 8, or 9');\n    break;\n}\n```\n\n","n":0.034}}},{"i":38,"$":{"0":{"v":"Expressions","n":1},"1":{"v":"## JavaScript expressions\n\nExpressions are anything JavaScript can evaluate to a value, including undefined and null.\n\nExamples:\n```js\n> 7 + (5 + 2)\n= 14\n\n> console.log(5 + 2)\n7\n= undefined\n```\nNote that without a return value, expressions return undefined. Console.log() outputs to a console but doesn't return anything, hence undefined.\n\nAny value is an expression that evaluates to itself.\n\n","n":0.139}}},{"i":39,"$":{"0":{"v":"Exceptions","n":1},"1":{"v":"## Exceptions\n\nExceptions are errors thrown by JavaScript, which halt the program. To continue the program, a ```catch``` statement can be used:\n```js\ntry {\n  // perform an operation that may produce an error\n} catch (exception) {\n  // an error occurred. do something about it.\n  // for example, log the error\n} finally {\n  // Optional 'finally' block; not used often\n  // Executes regardless of whether an exception occurs.\n}\n```\n\n### Syntax error\nThese occur as soon as JavaScript program is loaded and before it runs.","n":0.113}}},{"i":40,"$":{"0":{"v":"Dates","n":1},"1":{"v":"## Dates\n\nJavaScript includes a ```Date``` constructor to create objects for dates and times.\n```js\n> let date = new Date('December 25, 2012')\n> date.getDay() // returns day of the week (0-6)\n= 2\n```\nGet the day name example:\n```js\nfunction getDayOfWeek(date) {\n  let daysOfWeek = [\n    'Sunday',\n    'Monday',\n    'Tuesday',\n    'Wednesday',\n    'Thursday',\n    'Friday',\n    'Saturday',\n  ];\n\n  return daysOfWeek[date.getDay()];\n}\n\nlet date = new Date('December 25, 2012');\nconsole.log(getDayOfWeek(date)); // => Tuesday\n```","n":0.131}}},{"i":41,"$":{"0":{"v":"Data_types","n":1},"1":{"v":"## Data types in JavaScript\n\nThe five primitive data types in JavaScript\n\n* String\n* Number\n* Undefined\n* Null\n* Boolean\n\nAll non-primitive data types are object types.\n\nData type values can be represented by literals, a fixed value in JavaScript code.","n":0.169}}},{"i":42,"$":{"0":{"v":"Undefined","n":1},"1":{"v":"## Undefined in JavaScript\n\nUndefined represents the absense of a value.\n\nSome functions, such as console.log() return undefined because there's no value to return.\n\nWhen declaring a variable that hasn't been initialized to a value, that variable returns undefined.","n":0.167}}},{"i":43,"$":{"0":{"v":"Typeof","n":1},"1":{"v":"## Typeof operator in JavaScript\n\nThe typeof operator returns the data type of an operand.\n\nExample:\n```js\n> typeof 1\n= 'number'\n\n> typeof 'foo'\n= 'string'\n\n> typeof true\n= 'boolean'\n\n> typeof undefined\n= 'undefined'\n\n> typeof null\n= 'object' // That's just weird\n\n> typeof [1, 2, 3]\n= 'object' // You'd expect this to be an array, but arrays are objects\n```\n\n\nSince typeof is an operator and not a method, it doesn't use () like a method.","n":0.124}}},{"i":44,"$":{"0":{"v":"Strings","n":1},"1":{"v":"## Strings in JavaScript\n\nOne of the five primative [[Javascript.data_types]] in JavaScript.\n\nA string is a list of characters in sequence. String literals are enclosed in single or double quotes.\n\nEscape characters are used in strings to include a quote or double quote within the string literal. \n- Example: ```\\'```\n\nBackticks (`) are used for string template literals; these avoid some of the issues caused by quotes as you don't need to use escape characters to add them.\n\nBackticks enable string interpolation to include JavaScript expressions. \n- Example: ```Kevin is ${age} years old.```\n","n":0.107}}},{"i":45,"$":{"0":{"v":"Concatenation","n":1},"1":{"v":"\n## String concatenation\n\nUsing the plus sign, + , joins two string values.\n\nConcatenating two strings representing numbers combines them as if they were letters.\n\n```js\n> '1' + '2'\n= 12\n```\n\nConcatenating a string and a number returns a numeric value. If a number is present in the operation, string data is implicitly coerced to a number.\n\n```js\n> '1' + 2\n= '12'\n```","n":0.134}}},{"i":46,"$":{"0":{"v":"Properties","n":1},"1":{"v":"\nSome data types have properties in addition to methods available to them.\n\n```String.prototype.toUpperCase()``` is an example of a String method.\n\n```String.length``` is an example of the length property of a String.","n":0.186}}},{"i":47,"$":{"0":{"v":"Numbers","n":1},"1":{"v":"\n## Numbers in JavaScript\n\nUnlike other programming languages, JavaScript generally uses the Number data type for numeric data. \n\nCommas and periods are not allowed for grouping numbers. Example:\n```javascript\n10542 not 10,542 or 10.542 (which means 10 plus a fraction)\n```\n\n","n":0.164}}},{"i":48,"$":{"0":{"v":"Infinity","n":1},"1":{"v":"## Infinity and -Infinity in JavaScript\n\nInfinity is different from NaN; it's a number that's so large, it can't be represented numerically\n\nDivision by zero will return Infinity, except in the case of 0 / 0\n\n-Infinity is an infinate value less than zero.\n\nInfinity's type is Number\n\nYou can test for infinity with with strict equality\n\n```js\nlet value1 = Infinity\nvalue1 === Infinity\ntrue\n\nlet value2 = -Infinity\nvalue2 === -Infinity\n```","n":0.127}}},{"i":49,"$":{"0":{"v":"NaN","n":1},"1":{"v":"## NaN in JavaScript\n\nNaN is a value that represents \"Not a Number\". \n\nGenerally found in an illegal operation on numbers or trying to perform an operation on non-numeric data types.\n\nIt is of type Number:\n```js\n> typeof NaN\n= 'number'\n```\n\nNaN is common when:\n* Trying to divide by zero\n* Find the square root of negative number\n* Trying to convert a non-number value to a number\n\nNaN is the only JavaScript value not equal to itself. \n```js\n> let value = NaN;\n> value === NaN         // We'll talk about this in a few minutes\n= false\n\n> NaN === NaN\n= false\n```\n\nTo determine if a value is NaN, use one of the two following methods:\n```js\n> let value = NaN;\n> Number.isNaN(value)\n= true\n\n> Object.is(value, NaN)\n= true\n```\n","n":0.094}}},{"i":50,"$":{"0":{"v":"Null","n":1},"1":{"v":"## Null in JavaScript\n\nNull is similar to, but different from, undefined. It signifies the intentional absense of a value. It sometimes represents emptiness of nothing.\n\nNull must be used explicity, while undefinded can be used implicitly.\n\nExample of a variable without a value but is still defined to have a value:\n```js\n> let foo = null\n```\nIn this case, the literal value is null.","n":0.129}}},{"i":51,"$":{"0":{"v":"Booleans","n":1},"1":{"v":"## Booleans in JavaScript\n\nTwo boolean literal values only: true and false.\nThese are like \"on\" and \"off\", or \"0\" and \"-1\".\n\nUsed for comparisons they return the boolean result of \"true\" or \"false\".\nExample:\n```js \n> 5 === 5\n= true\n\n> 100 < 99\n= false\n```","n":0.158}}},{"i":52,"$":{"0":{"v":"Data structures","n":0.707},"1":{"v":"\n## Arrays\n\n## Objects","n":0.577}}},{"i":53,"$":{"0":{"v":"Objects vs Primitive Values","n":0.5},"1":{"v":"## Every value in JavaScript is either a primitive or an object\n\nThis tells us how the value is stored in memory, either in a \"pass by value\" or a \"pass by reference\" approach.\n\n## Primitives are atomic values\n\nThey can't be broken down; they are the \"smallest\" possible data type.\n\n## Objects are compound values\n\nObjects are comprised of either other objects and/or primitive values. Therefore they can be broken down to smaller bits.\n\n## Primitive values are immutable\n\nWe can't change the value of a primitive, we can only assign the value of one primitive to another one. This means the same variable will hold a new primitive value, not a modified one.\n\n## Objects are mutable\n\nWe can change objects in place because of the \"pass by reference\" approach","n":0.09}}},{"i":54,"$":{"0":{"v":"Objects","n":1},"1":{"v":"## Objects in JavaScript\n\nObjects can be a dictionary-like structure with keys matching unique values, i.e.: A key-value pair.\n\nObject literals are created with curly braces, {} , and keys separated from values with a colon, : Multiple key-value pairs are comma separated:\n```js\n> { dog: 'barks', cat: 'meows', pig: 'oinks' }\n= { dog: 'barks', cat: 'meows', pig: 'oinks' }\n```\n\nValues can be retrieved by their keys:\n```js\n> ({ dog: 'barks', cat: 'meows', pig: 'oinks' })['cat']\n= 'meows'\n// or objects variable name and key in brackets\n// animals['cat'];\n```\n\nOther languages have key-value pairs but refer to them as dictionaries (Python?), associative arrays, maps and hashes.\n\nObject keys in JavaScript are strings (quotes are not needed) or symbols. Values can be any type.Example of creating an object with object literal syntax:\n```js\n> let person = { name: 'Jane', age: 37, hobbies: ['photography', 'genealogy'] }\n```\n\nObject values are accessed with dot notation or bracket notation. The latter is required when a variable stores a key name.\n```js\n> person.name                 // dot notation\n= 'Jane'\n\n> person['age']               // bracket notation\n= 37\n```\n\nTo remove a value from an object, you can ```delete``` the object's key for that value. Doing so returns ```true``` unless the object property can't be deleted. Note: 'property' typically refers to an object key.\n\nWhen using ```const``` to declare and initialize an object, you can't change what the variable refers to. You can modify that object's properties and property values.\n\n```Object.freeze()``` prevents an object's properties from modification. This only works one level deep, however. Nested arrays or objects must be frozen to prevent modification.\n\n## Objects vs primitives\n\nObjects include simple objects, arrays, dates, functions and more. They're comprised of primitive values or other objects and are usually mutable.\n\nPrimitive values are always [immutable](https://developer.mozilla.org/en-US/docs/Glossary/Immutable) and considered atomic, i.e.; indivisible.\n\n\n\n### Functions are objects\n\nVariables can be assigned to functions.\nExample:\n```js\nfunction hello() {\n  console.log(\"Hello there!\");\n}\n\nhello();            // Prints \"Hello there!\"\n\nlet greet = hello;  // `greet` now points to the `hello` function\ngreet();            // Prints \"Hello there!\"\n```\n\nFunctions can be passed to other functions and can be returned by other functions. Example of passing a function to another function as an argument:\n```js\nArray.prototype.forEach = function(callback) {\n  for (let index = 0; index < this.length; index += 1) {\n    callback(this[index]);\n  }\n}\n\nlet array = [1, 2, 3];\narray.forEach(function callback(value) { console.log(value); })\n```\n\n### What things aren't objects or primitives?\n\nAnything that isn't data or a function isn't an object nor a primitive value:\n- Variables and function names\n- Statements (if, return, try, while, break)\n- Keywords (new, function, let, const, class)\n- Comments\n\n## Prototypes\n\nJavaScript objects can inherit properties from other objects.\n\nThe ```Object.create()``` method creates a new object that inherits properties from an existing object. Example where ```bob``` is the prototype for the ```studentBob``` object:\n```js\nlet bob = { name: 'Bob', age: 22 };\nlet studentBob = Object.create(bob);\nstudentBob.year = 'Senior';\n\nconsole.log(studentBob.name); // => 'Bob'\n```\n\n## Iteration\n\n### The for/in loop\n\nSimilar to a standard ```for``` loop but simpler as it iterates over all keys in an object. Example:\n\n```js\nlet person = {\n  name: 'Bob',\n  age: 30,\n  height: '6 ft'\n};\n\nfor (let prop in person) {\n  console.log(person[prop]);\n}                             // => Bob\n                              //    30\n                              //    6 ft\n```\n\n### Object keys\n\n```Object.keys()``` returns all of an object's own keys as an array. It does not return keys from any prototype objects.\n\n## Common Operations and Methods\n\n```Object.values()``` returns an object's own properties in an array. Example:\n```js\nlet person = { name: 'Bob', age: 30, height: '6ft' };\nlet personValues = Object.values(person);\nconsole.log(personValues); // => [ 'Bob', 30, '6ft' ]\n```\n\n```Object.entries()``` returns the keys and values of an object in a nested array. Example:\n```js\nlet person = { name: 'Bob', age: 30, height: '6ft' };\nconsole.log(Object.entries(person)); // => [[ 'name', 'Bob' ], [ 'age', 30 ], [ 'height', '6ft' ]]\n```\n\n```Object.assign()``` merges the keys and values of two or more objects into a single object. This mutates the first object so that it contains the merged object. Example:\n```js\n> let objA = { a: 'foo' }\n= undefined\n\n> let objB = { b: 'bar' }\n= undefined\n\n> Object.assign(objA, objB)\n= { a: 'foo', b: 'bar' }\n```\n\n## Objects vs. Arrays\n\nHow to choose between an object and an array for storing data:\n- If the values have individual names or labels, use and object.\n- If order matters, choose an array.\n- For stack and queue types of data, choose an array.\n\nNOTE: JavaScript will coerce non-string values when using them as object keys.\n\n\n\n\n\n\n","n":0.038}}},{"i":55,"$":{"0":{"v":"Arrays","n":1},"1":{"v":"## Arrays in JavaScript\n\nArrays are ordered lists that can contain any data type. Array literals are represented by square brackets [] with comma delimited values, aka: elements.\n\nExample of an array of numbers:\n```js\n> [1, 2, 3, 4, 5]\n[ 1, 2, 3, 4, 5 ]\n```\n\nTo access an array element, use its index value inside the brackets. Indexes are non-negative integers starting with zero.\n\nExample of getting the first element:\n```js\n> [1, 2, 3, 4, 5][0] // or arr[0] if arr contains the array\n= 1\n```\n\nCalling an array index equal to or greater than the array length returns 'undefined'.\n\n## What is an Array?\n\nArrays are heterogeneous, meaning they can hold multiple data types, including primitives, objects and other arrays (called sub-arrays). Arrays are also ordered, with each element accessible through a unique index number. Array indices start with the number zero. So arrays are both indexed lists as well as ordered lists.\n\nArray elements are accessed by their index number, in brackets. JavaScript provides the length of an array, useful for accessing the last element with the ```length``` property of an ```Array``` object.\n\nExample:\n```js\nlet names = [\"Kevin\", \"Barb\", \"Tyler\", \"Norm\"]\nconsole.log(names[2]); // Tyler\nconsole.log(names[names.length - 1]); // Norm is element 3 or length (4) - 1\n```\n\n## Modifying Arrays\n\nAny array element can be replaced by re-assigning the element's index with a new value. Example: ```names[3] = \"Gus\"```\n\nValues can be added to an array in a similar fashion, using ```names[names.length] and assigning a value to it.\n\nArrays declared as a ```const``` can't be reassigned, however the values in these arrays can be modified. To prevent this, use the ```Object.freeze()``` method on the array. This will ensure the array elements can not be changed unless dealing with nested arrays.\n\n### Adding Array Elements with ```push```\n\nUse the ```push()``` method to add an element to the end of an array. Pass the value of the element to the ```push()``` method. The method mutates the array and returns the new length property value of the mutated array.\n\n### Adding Array Elements with ```concat```\n\nUse the ```concat()``` method to concatenate two arrays and return a new array. This does not mutate the calling arrays.\n\nExample:\n```js\n> array.concat(42, 'abc')\n= [ 1, 4, 3, 10, 'a', null, 'xyz', 42, 'abc' ]\n\n> array\n= [ 1, 4, 3, 10, 'a', null, 'xyz' ]\n```\n\n### Removing Array Elements with ```pop```\n\nUse the ```pop()``` method to remove and return the last element of an array. Since the array elements are modified, the ```pop()``` method mutates the caller.\n\n### Removing Array Elements with ```splice```\n\nUse the ```splice()``` method to remove and return a range of elements. The original array is mutated by the ```splice()``` method because those elements have been removed.\n\nExample:\n```js\nlet array = [1, 4, 3, 10, \"a\", null];\n\n> array.splice(3, 2)\n[ 10, 'a' ]\n\n> array\n= [ 1, 4, 3, null ]\n```\n\n## Iteration methods for Arrays\n\n### Iterating arrays with ```forEach()```\nThis is similar to a ```for``` loop but generally preferred for style. A ```forEach()``` loop requires a callback function that is passed to ```forEach()``` as an argument. During each loop, the callback function is invoked one time for each element, with the element value passed as an argument. The return value of a ```forEach()``` loop is always ```undefined```.\n\nExample:\n```js\nlet array = [1, 2, 3];\narray.forEach(function(num) {\n  console.log(num); // on first iteration  => 1\n                    // on second iteration => 2\n                    // on third iteration  => 3\n}); // returns `undefined`\n```\n\nThis can also be done with an arrow function:\n\n```array.forEach(num => console.log(num));```\n\n### Transforming arrays with ```map()```\n\nThe ```map()``` function is more useful when creating a new array that contains modified elements from the original array. It reduces the risk of side effects because the original array is not mutated. Instead, it returns a new array, leaving the original intact.\n\nExample:\n```js\n> numbers.forEach(num => squares.push(num * num));\n> squares\n= [ 1, 4, 9, 16, 1, 4, 9, 16 ]\n\n> let numbers = [1, 2, 3, 4]\n> let squares = numbers.map(num => num * num);\n> squares\n= [ 1, 4, 9, 16 ]\n\n> squares = numbers.map(num => num * num);\n= [ 1, 4, 9, 16 ]\n```\nAlthough both methods work, ```forEach``` mutates the numbers array and returns ```undefined```, while ```map``` returns a new array.\n\n### Filtering Arrays with ```filter```\n\nLike ```map```, ```filter``` returns a new array. The difference is in the approach as ```filter``` returns truthy values from the callback function, which is generally some condition to return selected elements of the original array.\n\nExample:\n```js\n> let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2]\n> numbers.filter(num => num > 4)\n= [ 5, 6, 7, 8, 9, 10 ]\n\n> numbers\n= [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2 ]\n```\n\nLike ```map```, the ```filter``` method returns a new array and does not mutate the original array.\n\n### Building New Values from Arrays with ```reduce```\n\nThis method reduces all elements in an array to a single value. It's useful for computing values in a single array, such as adding or subtracting them all together.\n\nExample:\n```js\n> let arr = [2, 3, 5, 7]\n> arr.reduce((accumulator, element) => accumulator + element, 0)\n= 17\n\n> arr.reduce((accumulator, element) => accumulator * element, 1)\n= 210\n```\n\nThe ```reduce``` method takes two arguments: a callback function and an initialized value typically called the accumulator. Think of it like setting a counter variable to zero to begin a counting computation. The accumulator value is returned to the callback iteratively. Above, the accumulator is initialized to 0 for an addition function, and 1 for a multiplication function.\n\n## Some odd things about Arrays\n\nBecause of zero-indexing, the ```length``` property of an array is always one plus the highest index value.\nUsing the ```typeof``` operator on a array returns the value ```object```, not array. To verify if variable is referencing an array, use the ```Array.isArray(arr)``` method.\n\nYou can manually set or change the ```length``` of an array. Doing so with a value smaller than the current length value will truncate the elements after the final element of the new array. Doing so with a larger value creates more space by expanding the array size. However, the new indices are not initialized with any values, so they return ```undefined```.\n\nArray indices can be negative numbers but the elements assigned to them are not counted in the ```length``` property.\n\nYou can use the ```Object.keys(arr)``` method to return the index values because arrays are objects.\n\n## Nested arrays\n\nAn array that contains other arrays is called a nested array. When looking at an nested array value with a single index, it will return the entire nested array from the main array. By appending index values together, you can navigate and read through nested arrays.\n\nExample:\n```js\nlet scores = [['Kevin', 92], ['Barb\", 86], ['Tyler', 73]];\nconsole.log (scores[1][1]); // This returns Barb's score of 86\n```\n\n## Array equality\n\nWhen comparing arrays for equality, you can't use the ```===``` operator because two different arrays point to to different memory locations, even if their values are the same. (Note: This is true of all objects in JavaScript)\nExample:\n```js\n> [1, 2, 3] === [1, 2, 3]\n= false\n```\nHowever, if you create a new variable that points to the variable of an existing array, these would be equal because both variables point to the same memory location.\n\nTo verify that two arrays hold the same element, you need to compare each array element from the first array to the corresponding element in another array.\n\n## Other Array Methods\n\n### ```Array.includes()```\n\nThe ```includes``` method checks to see if an array contains the argument value as an element. Example:\n\n```js\n> let a = [1, 2, 3, 4, 5]\n> a.includes(2)\n= true\n\n> a.includes(10)\n= false\n```\n\n### ```Array.sort()```\n\nThe ```sort``` method mutates the passed array so that its elements are in order. This occurs in place, so the return value is a reference to the same array. Remember, arrays are unordered lists, so ```sort``` will order an array list.\n\n### ```Array.slice()```\n\nThe ```slice``` method returns the elements from a portion of an array. It takes two optional arguments: The index of where to start the sliced portion and the index of where to end the slice. The portion does not include the index value of the second parameter. Without any arguments passed, ```slice``` returns a new copy of the original array.\n\n### ```Array.reverse()```\n\nThe ```reverse``` method is destructive because it mutates the original array and returns the elements in reverse order.\n\n## Some exercises\n\n* Use the map function to create a new array that contains one element for each element in the original array. If the element is an even value, then the corresponding element in the new array should contain the string 'even'; otherwise, the element in the new array should contain 'odd'.\n\n```js\nlet myArray = [\n  1, 3, 6, 11,\n  4, 2, 4, 9,\n  17, 16, 0,\n];\n\nlet newArray = myArray.map(element =>(element % 2 === 0 ? 'even' : 'odd'));\nconsole.log(newArray);\n```\n\n* Write a findIntegers function that takes an array argument and returns an array that contains only the integers from the input array. Use the filter method in your function.\n\n```js\nconst findIntegers = (arrOfThings) => {\n  return arrOfThings.filter(element => Number.isInteger(element));\n}\nlet things = [1, 'a', '1', 3, NaN, 3.1415, -4, null, false];\nlet integers = findIntegers(things);\n\nconsole.log(integers); // => [1, 3, -4]\n```\n\n* Use map and filter to first determine the lengths of all the elements in an array of string values, then discard the even values (keep the odd values).\n\n```js\nconst findIntegers = ((list) => list.filter(item => Number.isInteger(item)));\nlet things = [1, 'a', '1', 3, NaN, 3.1415, -4, null, false];\nlet integers = findIntegers(things);\nconsole.log(integers); // => [1, 3, -4]\n```\n\n* Use map and filter to first determine the lengths of all the elements in an array of string values, then discard the even values (keep the odd values).\n\n```js\nconst oddLengths = (list) => list.filter(item => item.length % 2 ===1).map(item => item.length);\n\nlet arr = ['a', 'abcd', 'abcde', 'abc', 'ab'];\nconsole.log(oddLengths(arr)); // => [1, 5, 3]\n```\n\n* Use reduce to compute the sum of the squares of all of the numbers in an array.\n\n```js\nconst sumOfSquares = (list) => {\n  return list.reduce((accumulator, currentValue) => (currentValue * currentValue) + accumulator, 0);\n}\n\nlet array = [3, 5, 7];\nconsole.log(sumOfSquares(array)); // => 83\n```\n\n* Write a function similar to the oddLengths function from Exercise 6, but don't use map or filter. Instead, try to use the reduce method.\n\n```js\nfunction oddLengths(list) {\n  let output = [];\n  list.reduce((accumulator, currentValue) => { // can refactor to use accumulator as array instead of output\n    if (currentValue.length % 2=== 1)\n      output.push(currentValue.length)\n  }, 1);\n  return output;\n}\n\nlet arr = ['a', 'abcd', 'abcde', 'abc', 'ab'];\nconsole.log(oddLengths(arr)); // => [1, 5, 3]\n```\n\n* Without using a for, while, or do/while loop, write some code that checks whether the number 3 appears inside these arrays:\n\n```js\n\n// Easier way is to just pass array and use the .includes() function. \nconst isThree = (element) => element === 3;\nconst threePresent  = (list) => list.some(isThree);\n\nlet numbers1 = [1, 3, 5, 7, 9, 11];\nlet numbers2 = [];\nlet numbers3 = [2, 4, 6, 8];\n```\n* Write some code to replace the value 6 in the following array with 606:\n\n```js\nlet arr = [\n  [\"hello\", \"world\"],\n  [\"example\", \"mem\", null, 6, 88],\n  [4, 8, 12]\n];\n\narr[1][3] = 606;\n```\n\n\n","n":0.024}}},{"i":56,"$":{"0":{"v":"Constants","n":1},"1":{"v":"'const' is similar to 'let' but is for constant values that are immutable. They can't be assigned a new value.\n\n```js\nconst INTEREST_RATE = 0.0783;\nINTEREST_RATE = 0.0788; // Uncaught TypeError: Assignment to constant variable.\n```\n\nYou can't simply declare a constant value; you have to initialize it, or assign, it a value at the same time.","n":0.139}}},{"i":57,"$":{"0":{"v":"Coercion","n":1},"1":{"v":"## Explicit Coercion\n\nIf we want to change a data type, such as a string of numbers to a Number type, we perform an explicit type coercion.\n\n- String to Numbers\n\nUse the Number function to coerce a string to a number:\n```js\n> Number('1')\n= 1\n```\n\nThe Number function accepts a string value argument, returning a number if the string is comprised of valid numeric data. \n\n**If the string doesn't have valid numeric data, ```Number()``` will return ```NaN```**\n\n**Coercing an empty string to a number returns a ```0```**\n\n**Coercing a boolean value from ```true``` returns a ```1``` while coercing ```false``` returns a ```0```**\n\n- parseInt() function alternative\n\nSimilar to the Number() function for coercion but works with a mix of string data comprised of numbers and non-numeric characters. \n\n**```parseInt()``` will convert string numbers until it reaches an invalid character.**\n\n```js\n> parseInt('12xyz')\n= 12\n```\nNote that if you pass a fractional character to parseInt() it will only return the integer value, not any decimal values less than 1.\n```js\n> parseInt('3.1415')\n= 3\n```\n\n**```parseInt()``` can accept a second argument called the radix; this indicates the base of the number argument, i.e.: radix of 2 = base 2**\n\n- parseFloat() alternative\n\nHowever, the parseFloat() function will handle fractional numbers for explicit coercion.\n```js\n> parseFloat('12.5foo')\n= 12.5\n```\n\n- Numbers to strings\n\nTo explicitly coerce numbers into a string data type, use the String() function.\n\n** This function can be used on ```undefined``` and ```null``` while the ```toString()``` can not.**\n\n```js\n> String(20)\n= '20'\n```\n\n- Using the unary ```+``` operator to coerce strings to numbers\n\n```js\n+'1' // returns the number value 1\n```\n\n- Coercing values to strings with the ```toString()``` method\n```js\nlet number = 123;\nconsole.log(number.toString()); // returns the string \"123\"\n```\nThis can also be used on arrays:\n```js\n[1, 2, 3].toString(); // returns the concatenated string \"1, 2, 3\";\n```\n\n## Implicit Coercion\n\n- Using the ```==``` operator\n\nThe non-strict equality operator will coerce values that are not of the same type:\n\n1. When a number is compared with a string using ==, the string is coerced into a number.\n2. When a boolean is compared with any other value, it is coerced into a number and compared again using the == operator.\n3. When an object is compared with a primitive value, the object is coerced into a primitive value and compared again using the == operator.\n4. A == comparison of undefined with null evaluates as true.\n\n** When using the non-strict equality operator on two objects, it only returns true if they are the same object.**\n\n- Using the binary ```+``` operator\n\nWhen one of the operands is a string, the ```+``` operator will coerce the other operand to a string and concatenate them.\n```js\nconsole.log('number ' + 1); // returns the string 'number 1'\n```\n\nWhen one of the operands is an object, both are converted to strings and concatenated:\n```js\n[1] + 2;        // \"12\"\n[1] + '2';      // \"12\"\n[1, 2] + 3;     // \"1,23\"\n[] + 5;         // \"5\"\n[] + true;      // \"true\"\n42 + {};        // \"42[object Object]\"\n```\n\n\n","n":0.047}}},{"i":58,"$":{"0":{"v":"Call Stack","n":0.707},"1":{"v":"## The Call Stack in JavaScript\n\nThis stack tracks what function is executing and what other functions haven't yet executed. It's an ordered stack (LIFO) of functions as they're invoked or called. The stack is created with stack frames; one frame for each function invocation.\n\n[From the MDN](https://developer.mozilla.org/en-US/docs/Glossary/Call_stack):\n- When a script calls a function, the interpreter adds it to the call stack and then starts carrying out the function.\n- Any functions that are called by that function are added to the call stack further up, and run where their calls are reached.\n- When the current function is finished, the interpreter takes it off the stack and resumes execution where it left off in the last code listing.\n- If the stack takes up more space than it was assigned, a \"stack overflow\" error is thrown.\n\n![](/assets/images/2022-12-29-12-09-33.png)\n\n## Stack Trace\n\n[JavaScript exception errors](./javascript.exceptions.md) return a stack trace, showing the type of error and where it occurred.\nExample:\n```js\n$ node error.js\n/Users/wolfy/tmp/x.js:2\n  console.log(bar);\n\nReferenceError: bar is not defined\n    at foo (error.js:2:15)\n    at Object.<anonymous> (error.js:5:1)\n    ...\n```\n","n":0.078}}}]}
